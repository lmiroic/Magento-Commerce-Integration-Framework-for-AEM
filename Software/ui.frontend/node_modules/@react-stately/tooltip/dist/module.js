import { useOverlayTriggerState } from "@react-stately/overlays";
import { useEffect, useMemo, useRef } from "react";
const $af9cde49ea815e766aeca6386e9$var$TOOLTIP_DELAY = 1500; // this seems to be a 1.5 second delay, check with design

const $af9cde49ea815e766aeca6386e9$var$TOOLTIP_COOLDOWN = 500;
let $af9cde49ea815e766aeca6386e9$var$tooltips = {};
let $af9cde49ea815e766aeca6386e9$var$tooltipId = 0;
let $af9cde49ea815e766aeca6386e9$var$globalWarmedUp = false;
let $af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout = null;
let $af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout = null;
/**
 * Manages state for a tooltip trigger. Tracks whether the tooltip is open, and provides
 * methods to toggle this state. Ensures only one tooltip is open at a time and controls
 * the delay for showing a tooltip.
 */

export function useTooltipTriggerState(props) {
  if (props === void 0) {
    props = {};
  }

  let {
    delay = $af9cde49ea815e766aeca6386e9$var$TOOLTIP_DELAY
  } = props;
  let {
    isOpen,
    open,
    close
  } = useOverlayTriggerState(props);
  let id = useMemo(() => "" + ++$af9cde49ea815e766aeca6386e9$var$tooltipId, []);
  let closeTimeout = useRef();

  let ensureTooltipEntry = () => {
    $af9cde49ea815e766aeca6386e9$var$tooltips[id] = hideTooltip;
  };

  let closeOpenTooltips = () => {
    for (let hideTooltipId in $af9cde49ea815e766aeca6386e9$var$tooltips) {
      if (hideTooltipId !== id) {
        $af9cde49ea815e766aeca6386e9$var$tooltips[hideTooltipId](true);
        delete $af9cde49ea815e766aeca6386e9$var$tooltips[hideTooltipId];
      }
    }
  };

  let showTooltip = () => {
    clearTimeout(closeTimeout.current);
    closeTimeout.current = null;
    closeOpenTooltips();
    ensureTooltipEntry();
    $af9cde49ea815e766aeca6386e9$var$globalWarmedUp = true;
    open();

    if ($af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout) {
      clearTimeout($af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout);
      $af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout = null;
    }

    if ($af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout) {
      clearTimeout($af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout);
      $af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout = null;
    }
  };

  let hideTooltip = immediate => {
    if (immediate) {
      clearTimeout(closeTimeout.current);
      closeTimeout.current = null;
      close();
    } else if (!closeTimeout.current) {
      closeTimeout.current = setTimeout(() => {
        closeTimeout.current = null;
        close();
      }, $af9cde49ea815e766aeca6386e9$var$TOOLTIP_COOLDOWN);
    }

    if ($af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout) {
      clearTimeout($af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout);
      $af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout = null;
    }

    if ($af9cde49ea815e766aeca6386e9$var$globalWarmedUp) {
      if ($af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout) {
        clearTimeout($af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout);
      }

      $af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout = setTimeout(() => {
        delete $af9cde49ea815e766aeca6386e9$var$tooltips[id];
        $af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout = null;
        $af9cde49ea815e766aeca6386e9$var$globalWarmedUp = false;
      }, $af9cde49ea815e766aeca6386e9$var$TOOLTIP_COOLDOWN);
    }
  };

  let warmupTooltip = () => {
    closeOpenTooltips();
    ensureTooltipEntry();

    if (!isOpen && !$af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout && !$af9cde49ea815e766aeca6386e9$var$globalWarmedUp) {
      $af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout = setTimeout(() => {
        $af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout = null;
        $af9cde49ea815e766aeca6386e9$var$globalWarmedUp = true;
        showTooltip();
      }, delay);
    } else if (!isOpen) {
      showTooltip();
    }
  }; // eslint-disable-next-line arrow-body-style


  useEffect(() => {
    return () => {
      clearTimeout(closeTimeout.current);
      let tooltip = $af9cde49ea815e766aeca6386e9$var$tooltips[id];

      if (tooltip) {
        delete $af9cde49ea815e766aeca6386e9$var$tooltips[id];
      }
    };
  }, [id]);
  return {
    isOpen,
    open: immediate => {
      if (!immediate && delay > 0 && !closeTimeout.current) {
        warmupTooltip();
      } else {
        showTooltip();
      }
    },
    close: hideTooltip
  };
}
//# sourceMappingURL=module.js.map
